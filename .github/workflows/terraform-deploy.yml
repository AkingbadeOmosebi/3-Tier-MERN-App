name: Terraform Infrastructure Deployment
# I trigger this workflow on push to main branch only
# This ensures only approved changes (merged PRs) get deployed
on:
  push:
    branches:
      - main
    paths:
      - 'terraform/**'
      - '!terraform/oidc/**' # Exclude OIDC config changes, hence the '!' to represent negation
      - '.github/workflows/terraform-*.yml'

# Required permissions for OIDC authentication
permissions:
  id-token: write    # Required for OIDC token request
  contents: read    # Required to checkout code
  pull-requests: write  # Required to comment on PRs
  issues: write

jobs:
  # Security scanning runs first - fail fast if issues found
  security-scan:
    name: Security Scanning with Checkov
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Run Checkov security scan
        uses: bridgecrewio/checkov-action@master
        with:
          directory: terraform/
          skip_path: terraform/oidc # I exclude OIDC from scanning
          framework: terraform
          output_format: cli
          soft_fail: true  # It wont fail workflow if critical issues found
    
  # Cost estimation runs after security scan using infracost
  cost-estimation:
    name: Cost Estimation with Infracost
    runs-on: ubuntu-latest
    needs: security-scan
    timeout-minutes: 15
    strategy:
      matrix:
        module: ['core-infra', 'networking', 'cosmos-db', 'aks-cluster'] # List of modules to estimate costs for # Rearranged for logical order, DB should come before AKS and core-infra before networking
      max-parallel: 1   # Each are ordered in dependent sequence
      fail-fast: false
    
    defaults:
      run:
        working-directory: terraform/${{ matrix.module }} # Set working directory per module

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.0
          terraform_wrapper: false

      - name: Setup Infracost
        uses: infracost/actions/setup@v3
        with:
          api-key: ${{ secrets.INFRACOST_API_KEY }}     # My personal Infracost API key from secrets

      - name: Generate Infracost JSON       
        run: |
          infracost breakdown --path . \
            --format json \
            --out-file /tmp/infracost-${{ matrix.module }}.json

      - name: Upload cost estimate artifact
        uses: actions/upload-artifact@v4
        with:
          name: infracost-${{ matrix.module }}
          path: /tmp/infracost-${{ matrix.module }}.json
          retention-days: 7

      - name: Post cost estimate to summary
        run: |
          echo "## Cost Estimate: ${{ matrix.module }}" >> $GITHUB_STEP_SUMMARY
          infracost output --path /tmp/infracost-${{ matrix.module }}.json --format table >> $GITHUB_STEP_SUMMARY
    
  # Deploy infrastructure modules sequentially with dependencies
  deploy:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [security-scan, cost-estimation] # Only deploy if security scan passes
    environment: production # I deploy to production environment# This triggers manual approval requirement which i set in environment settings bar
    timeout-minutes: 60 # Adjust timeout as needed

    # I deploy modules in strict order due to dependencies
    strategy:
      matrix:
        module: ['core-infra', 'networking', 'cosmos-db', 'aks-cluster'] # Ordered by dependencies: core-infra -> networking -> cosmos-db -> aks-cluster
      max-parallel: 1   # Deploy one module at a time, no parallelization
      fail-fast: true   # Stop entire deployment if any module fails

    defaults:
      run:
        working-directory: terraform/${{ matrix.module }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.0

      - name: Terraform init
        run: terraform init
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_USE_OIDC: true

      - name: Terraform validate
        run: terraform validate

      - name: Terraform plan
        id: plan
        run: terraform plan -no-color -out=tfplan
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_USE_OIDC: true
          TF_VAR_subscription_id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform apply
        run: terraform apply -auto-approve tfplan
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_USE_OIDC: true
          TF_VAR_subscription_id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

  notify:
    name: Create Deployment Issue
    runs-on: ubuntu-latest
    needs: deploy
    if: always()    # Run even if deployment fails
    timeout-minutes: 5
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create deployment status issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const deployResult = '${{ needs.deploy.result }}';
            const timestamp = new Date().toISOString();
            const runUrl = `https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}`;
            
            let title, body, labels;
            
            if (deployResult === 'success') {
              title = `Deployment Successful - ${timestamp}`;
              body = `## Infrastructure Deployment Completed
              
              **Status:** Success
              **Triggered by:** @${{ github.actor }}
              **Commit:** ${{ github.sha }}
              **Branch:** ${{ github.ref_name }}
              **Workflow Run:** [View Details](${runUrl})
              
              ### Modules Deployed
              - networking
              - core-infra
              - aks-cluster
              - cosmos-db
              
              All infrastructure modules have been successfully deployed to production.`;
              labels = ['deployment', 'success', 'production'];
            } else {
              title = `Deployment Failed - ${timestamp}`;
              body = `## Infrastructure Deployment Failed
              
              **Status:** Failed
              **Triggered by:** @${{ github.actor }}
              **Commit:** ${{ github.sha }}
              **Branch:** ${{ github.ref_name }}
              **Workflow Run:** [View Details](${runUrl})
              
              ### Action Required
              Please review the workflow logs to identify the failure cause.
              
              ### Troubleshooting Steps
              1. Check the workflow run logs
              2. Verify Azure credentials and permissions
              3. Review Terraform state for conflicts
              4. Check for resource quota limits
              
              cc: @${{ github.actor }}`;
              labels = ['deployment', 'failure', 'production', 'urgent'];
            }
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: labels
            });
